<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Yolov10小知识</title>
    <url>/2024/05/26/Yolov10%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p> 今天突然发现都出了YOLOv10了，技术真的变更的好快，以下是本人学习的一些小知识。</p>
<p>为了提升性能效率边界，这一次改进的是后处理和模型架构。</p>
<p>在原来，YOLO后处理依赖着非极大值抑制（NMS），性能对NMS的超参数敏感，阻碍了YOLO的端到端部署，产生了一定的推理延迟。</p>
<p>增强特征提取能力可以考虑以下模块：DarkNet、CSPNet、EfficientRep和ELAN等</p>
<p>DarkNet是yolov3里面的backbone，主要是由重复堆叠下采样卷积+n*残差块组成。主要是由cnn卷积核提取特征。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/14b426a4f6b44003b64dd82a14daa2d7.png"
                      alt="图片"
                ></p>
<p>CSPNet的主要目的是使该体系结构能够实现更丰富的梯度组合，同时减少计算量。</p>
<p>增强多尺度特征融合：PAN、BiC、GD和RepGFPN等</p>
<p>模型缩放策略和重新参数化技术</p>
]]></content>
      <tags>
        <tag>Object Detection</tag>
      </tags>
  </entry>
  <entry>
    <title>进程调度算法</title>
    <url>/2024/08/28/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="先来先服务调度算法FCFS"><a href="#先来先服务调度算法FCFS" class="headerlink" title="先来先服务调度算法FCFS"></a>先来先服务调度算法FCFS</h2><p><strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p>
<p>对短作业不利。</p>
<p>适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p>
<h2 id="最短作业优先调度算法SJF"><a href="#最短作业优先调度算法SJF" class="headerlink" title="最短作业优先调度算法SJF"></a>最短作业优先调度算法SJF</h2><p><strong>优先选择运行时间最短的进程来运行</strong>，这有助于提高系统的吞吐量。</p>
<p>对长作业不利，被推迟到很后面。</p>
<h2 id="高响应比优先调度算法HRRN"><a href="#高响应比优先调度算法HRRN" class="headerlink" title="高响应比优先调度算法HRRN"></a>高响应比优先调度算法HRRN</h2><p>进程调度先运行响应比优先级最高的。<br>$$<br>优先权&#x3D; \frac { 等待时间+要求服务时间 }{ 要求服务时间 }<br>$$<br>兼顾长作业和短作业。</p>
<h2 id="时间片轮转调度算法RR"><a href="#时间片轮转调度算法RR" class="headerlink" title="时间片轮转调度算法RR"></a>时间片轮转调度算法RR</h2><p><strong>使用最广</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/image-20240828124832086.png"
                      alt="image-20240828124832086"
                ></p>
<p>每个进程被分配一个时间段，称为时间片，即在该时间内可以为该进程运行。</p>
<ul>
<li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；</li>
<li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；</li>
</ul>
<p>另外，时间片的长度就是一个很关键的点：</p>
<ul>
<li>如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；</li>
<li>如果设得太长又可能引起对短作业进程的响应时间变长。将</li>
</ul>
<p>通常时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>数模</tag>
      </tags>
  </entry>
  <entry>
    <title>about_conda</title>
    <url>/2024/07/09/about-conda/</url>
    <content><![CDATA[<p>记录一下常用的conda命令</p>
<p>查看版本</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure></div>

<p>查看环境配置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda config --show</span><br></pre></td></tr></table></figure></div>

<p>更新conda</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure></div>

<p>创建虚拟环境</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n env_name python=3.9</span><br></pre></td></tr></table></figure></div>

<p>查看虚拟环境</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda env list</span><br><span class="line">conda info -e</span><br><span class="line">conda info --envs</span><br></pre></td></tr></table></figure></div>

<p>激活虚拟环境</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda activate env_name</span><br></pre></td></tr></table></figure></div>

<p>退出虚拟环境</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda deactivate</span><br></pre></td></tr></table></figure></div>

<p>删除虚拟环境</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda remove --name env_name --all</span><br></pre></td></tr></table></figure></div>

<p>删除虚拟环境中的某些包</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda remove --name env_name  package_name</span><br></pre></td></tr></table></figure></div>

<p>查看环境中有的包</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure></div>

<p>克隆虚拟环境</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda create -n BBB --clone AAA</span><br></pre></td></tr></table></figure></div>

<p>在本地的conda环境AAA，克隆给新环境BBB</p>
]]></content>
  </entry>
  <entry>
    <title>如何读论文</title>
    <url>/2024/02/16/begin/</url>
    <content><![CDATA[<h1 id="如何读论文"><a href="#如何读论文" class="headerlink" title="如何读论文"></a>如何读论文</h1><p>从头开始看一篇论文所花的时间太久了，而且记忆不深，就没什么效果（对我来说），所以在参考了学长的观点后，我觉得可以从以下结构开始阅读：</p>
<table>
<thead>
<tr>
<th align="center">原来结构</th>
<th align="center">推荐结构</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Abstract</td>
<td align="center">Abstract(摘要)</td>
</tr>
<tr>
<td align="center">Introduction</td>
<td align="center">Discussion（讨论）</td>
</tr>
<tr>
<td align="center">Methods</td>
<td align="center">Introduction（导言）</td>
</tr>
<tr>
<td align="center">Results</td>
<td align="center">Results（结果）</td>
</tr>
<tr>
<td align="center">Discussion</td>
<td align="center">Methods（方法）</td>
</tr>
</tbody></table>
<h2 id="Abstract-摘要"><a href="#Abstract-摘要" class="headerlink" title="Abstract(摘要)"></a>Abstract(摘要)</h2><p>关注四个信息：</p>
<ul>
<li>研究目的（为什么要研究）</li>
<li>方法（如何研究）</li>
<li>结果（发现了什么）</li>
<li>结论（它意味着什么）</li>
</ul>
<h2 id="Discussion（讨论）"><a href="#Discussion（讨论）" class="headerlink" title="Discussion（讨论）"></a>Discussion（讨论）</h2><p>内容一般是：</p>
<ul>
<li>明确回答introduction中提出的问题</li>
<li>解释结果如何支持结论</li>
</ul>
<p>看看自己是否理解和相信作者的观点</p>
<h2 id="Introduction（导言）"><a href="#Introduction（导言）" class="headerlink" title="Introduction（导言）"></a>Introduction（导言）</h2><p>作用：</p>
<ul>
<li>激发我们对主题的兴趣</li>
<li>将文章置于大背景中</li>
</ul>
<p>一般来说，先引导作者从一般问题（对主题的已知了解）到具体问题（对主题的未知了解），再到重点问题（作者提出的问题）。所以要介绍之前的作品以及这些作品与该主题的关系。</p>
<p>想想作者为什么要做这个研究，研究的问题和讨论的问题是否一致</p>
<h2 id="Results（结果）"><a href="#Results（结果）" class="headerlink" title="Results（结果）"></a>Results（结果）</h2><p>内容一般是：</p>
<ul>
<li>作者的发现</li>
<li>关键数据，通常用图表显示</li>
</ul>
<p>问问自己所收集的数据是否适合回答所研究的问题</p>
<h2 id="Methods（方法）"><a href="#Methods（方法）" class="headerlink" title="Methods（方法）"></a>Methods（方法）</h2><ul>
<li>做了哪些实验来回答引言中提出的问题</li>
</ul>
<h2 id="如何找到文章的要点"><a href="#如何找到文章的要点" class="headerlink" title="如何找到文章的要点"></a>如何找到文章的要点</h2><p>主要地方包括：</p>
<ul>
<li><p>文章标题</p>
</li>
<li><p>Abstract</p>
</li>
<li><p>Keywords</p>
<ul>
<li>“We hypothesize that…”（假设）</li>
<li>“We propose…”(建议)</li>
<li>“We introduce…”（提出）</li>
</ul>
</li>
<li><p>图表的标题</p>
</li>
<li><p>introduction的第一句和最后一句</p>
</li>
</ul>
<h2 id="notes"><a href="#notes" class="headerlink" title="notes"></a>notes</h2><p>做笔记也是阅读文献中比较重要的一步，用固定的格式比较方便查找：</p>
<ul>
<li><strong>Article title</strong>（文章标题）</li>
<li>作者，期刊</li>
<li>有关方向</li>
<li>阅读日期</li>
<li>网址</li>
<li>主要概念（推荐结构）</li>
<li>我自己的想法</li>
</ul>
]]></content>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
</search>
